using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CSharpDynamicProg
{
    public static class Backpack
    {
        /// <summary>
        /// Метод решения дискретной задачи о рюкзаке методом динамического программирования
        /// </summary>
        /// <param name="mmax">Максимальная масса рюкзака, т.е. максимальная масса предметов которые мы можем унести</param>
        /// <param name="weights">массив весов имеющихся предметов</param>
        /// <param name="values">массив стоимостей имеющихся предметов</param>
        /// <returns></returns>
        public static List<int> DiscreteBackpack(int mmax, int[] weights, int[] values)
        {
            //Составим таблицу, где каждая строка соответствует предмету, а каждая колонка соответствует вместимости рюкзака < mmax, дискретно с шагом 1 [1:mmax]
            //В каждой клетке будет хранится максимальная стоимость для рюкзака вместимостью j при условии наличия набора преметов [0:i]
            //У таблички будет нулевая колонка и нулевой столбец для удобства вычислений. Нулевым значениям массивов weights и values будет соответствовать строка с индексом 1 и т.д
            var result = new int[weights.Length + 1, mmax + 1]; //Наш результат будет в последнем столбце последней строки
            
            for(int i = 1; i < weights.Length+1; i++) //Цикл по предметам
            {
                var currentW = weights[i - 1]; //Вес текущего предмета (для наглядности дальнейших вычислений)
                for(int j = 1; j < mmax + 1; j++) //Будем вычислять максимальную стоимость рюкзака размера j при условии доступности предмета i и всех предыдущих
                {
                    if(currentW > j) //Предмет не влазит в пустой рюкзак такого размера
                    {
                        //Взять подсчитанное макс значение для рюкзака этого размера для предыдущих предметов
                        result[i, j] = result[i - 1, j];
                    }
                    else //Предмет влазит в рюкзак размера j
                    {   //Варианты:
                        //Предмет может влезать только сам по себе и быть дороже набора предыдущих предметов
                        //Может влезать сам по себе но не быть дороже других рассмотренных вариантов для рюкзака такого объема
                        //Может влезать и еще будет оставаться свободное место для других предметов из ранее рассмотренного набора
                        //Общий случай - мы рассматриваем стоимость рюкзака с этим предметом + стоимость рюкзака предыдущих предметов, объем которого остался (может быть ноль)
                        //Нужно найти максимум из этого числа и стоимости рюкзака такого же объема но без этого предмета (вдруг он влазит, но дешёвый и предыдущие варианты лучше)
                        result[i, j] = Math.Max(values[i-1] + result[i - 1, j - currentW], result[i - 1, j]);
                    }
                }
            }
            return GetResultSet(result, mmax, weights);

        }
        /// <summary>
        /// Получить список индексов предметов для оптимального рюкзака
        /// </summary>
        /// <param name="arr">результаты работы алгоритма</param>
        /// <param name="m">макс масса (кол-во колонок таблицы, включая 0)</param>
        /// <param name="n">кол-во предметов (кол-во строк, включая 0)</param>
        /// <returns></returns>
        private static List<int> GetResultSet(int[,] arr, int m, int[] weights)
        {
            var result = new List<int>();
            var maxV = arr[weights.Length, m];
            var maxM = m;
            for(int i = weights.Length; i > 0; i--) //Пойдем по строкам снизу вверх
            {
                if(arr[i, maxM] == arr[i - 1, maxM]) //если стоимость с текущим предметом равна стоимости без текущего предмета - значит он не является компонентом макс стоимости
                    continue;
                result.Add(i); // Добавим индекс предмета в список результатов
                maxM -= weights[i]; //Вычтем 
            }

            return result;
        }
    }
}
